# 기억장치에 대한 이해

기억장치 (정보, 자료를 저장하는 공간 / 특성이 다름:속도, 휘발성 )
1. 주 기억장치
2. 보조 기억장치

## 기억장치 종류와 역할

```
	cpu		register
	L		l1, l2, l3, cache memory
computer	ram

external	hdd, ssd, usb disk
			backup device
```

밑으로 갈수록 용량이 크다. 대신 속도는 느려짐.

연산은 cpu가 한다. (연산은 register에서 이루어짐)
그 연산을 하기 위해서 ram에 가서 그 안의 자료를 이동시켜야 한다.
그 가져온 자료를 cpu에서 연산하고 그걸 다시 ram으로 보낸다.
이걸 다시 hdd(영구저장)로 보낸다. / 화면에 내보낸다.
ram은 cpu가 관리한다.


### 컴퓨터가 기억공간을 관리하는 방법
- 컴퓨터는 기본적으로 다 숫자이다.
- 정보가 저장된 위치도 숫자로 표시한다.
- 레지스터, 주 기억장치(RAM), 보조기억장치를 관리하는 방법은 조금씩 다르다.
	- 레지스터는 개별 기억공간마다 고유 **이름**을 붙인다. (메모리가 얼마 있지도 않음)
	- 주 기억장치는 **일련번호**를 붙인다.
	- 보조기억장치는 **트랙 번호와 섹터 번호**를 붙여 관리한다. 
		- 하드디스크 어딘가에 위치 정보가 있는데 이 정보를 식별하기 위한  

### HDD의 논리적 구조
트랙과 섹터로 구분해 관리한다. 섹터 수와 트랙을 곱하면 하드 디스크의 용량을 알 수 있다.
hdd를 조각냄 (세로로 자름: Sector, 가로로 자름: Track)
이걸 쓰려면 format을 해야한다. (아무것도 없는 곳에 트랙과 섹터를 만듦)
위치정보는 track과 sector로 알 수 있다.
정보가 조각내어져서 저장되어 있으면 디스크가 많이 돌아야해서 입출력 속도가 낮아진다.
이거를 한번에 붙여주는게 '조각모음'이다.
File Allocation Table
file을 삭제하면 FAT에 del에 체크가 됨, cpu가 비었다고 생각해서 오버라이딩 할 수 있다.
오버라이딩되기 전에는 복구할 수 있다.


### 주기억장치(ram) 기억공간은 '일련번호'로 관리한다.
ram은 1바이트 단위마다 정보를 가지고 있다.
```
신발장 = RAM
신발장 1칸 = 1byte
일련번호 = 주소 (위치 정보)
신발 = 정보
```  
4GB의 RAM에는 2^32 = 4,294,967,296가지의 번호가 있다.
32 bit에서 메모리를 관리할 때 최대 4gb를 관리할 수 있다.

### 컴퓨터가 연산하는 과정
hdd -> RAM -> CPU (전가산기로 연산)
(저속)	(고속)	(초고속)
cpu가 연산이 초고속으로 빠른데 RAM은 cpu보다 느림.
cache는 cpu가 연산할 걸 예측해서 정보를 미리 가져옴.
```
1. ram에서 정보를 가져옴
2. cache같은데 가지고 감 / cpu로 가져감
3. 레지스터로 옮김(복사)
4. aul 연산장치가 연산
5. 결과가 register에 들어감
6. 이 register에 들어가 있는걸 ram에 다시 옮김
=> 기계어 코드
```



## 숫자로 글자와 사진을 다루는 방법

컴퓨터 안에 존재하는 모든 (정보)것은 숫자이다.
십진수 65 = 영문 대문자 A
ASCII는 미국에서 사용하는 표준 코드 체계이다.
숫자와 글자를 구별하지 않고 정보를 말할 때는 바이너리라고 한다.

```
Love (문자열)
76 111 118 101
```

### 사진을 다루는 방법
특정 화소 하나를 숫자로 표시하고 여러 픽셀을 한데 모아 사진으로 그려낸다.
- 모니터 화면 상 '점'하나를 화소라고 한다.
- 여러 점들을 모아서 사진을 만든다.
- 화소 하나를 표현하는데 8비트, 16비트, 32비트, 64비트의 정보가 필요할 수 있다.
- 빛의 3원색은 rgb이다. 이 점에 착안해 RGB컬러가 등장한다.





----------

# 넓고 얕은 자료구조와 알고리즘

자료구조: 접근해서 사용하는 정보를 적절히 구조화한다. (접근성이 우수)
알고리즘: 어떤 규칙으로 접근하고 구조화하는가 (효과적이게)

### 어떻게 정리할 것인가?
'정리'라는 행위는 상황에 맞는 적절한 규칙이 존재한다.
- 특정한 순서로 정렬(Sort)한다.
- 분야를 나누고 성질이 비슷한 것들을 따로 모은다.
- 필요하다면 '단위'와 '규격'을 만든다.
- 일정규칙으로 정리된 자료가 자료구조이다. 
- 구조화된 자료에서 원하는 것을 빨리 찾아내는 방법은 알고리즘이다.

### 스택(Stack)
선형구조
- Last In First Out 구조
- 처음 넣은 것은 맨 아래
- 그 다음 넣은 것들은 그 위에 쌓인다
- 이런 구조가 필요한 이유: 되돌아가기 위해서

### 큐 (Queue)
- First In First Out 구조

### 연결리스트(Linked list)와 배열

- 배열은 자료가 연접하고 있다.
- 한 자료에 접근하고 그 다음으로 넘어갈 때 별로 생각할 것이 없다.
- 크기를 늘리거나 줄이려면 구조를 변경해야 하는 문제가 있다.

- 각자 따로 떨어진 자료를 위치 정보로 묶은 것이다.
- 한 자료에 접근한 후 다음으로 넘어가려면 위치정보를 활용해 찾아가야한다.
- 배열에 비해 복잡하다.
- 순서를 바꾸기가 매우 쉽다.
- 중간에 새로운 자료를 넣거나 빼기도 쉽다.

### 이진트리

비선형 자료구조 (트리, 그래프)
2차원적 구조를 갖는 비선형 자료구조로 선형 구조에 비해 성능이 우수하다.


------------------------------


# 운영체제가 하는 일

접근제어 + 동기화 + 관리(전산 지원)
- 프로그램들(프로세스) 관리하기

- 컴퓨터가 국가라면 운영체제는 정부조직이다. 스레드는 국민이고 프로세스는 가족이다.


누구는 대기하고 누구는 연산하고 이런거 = 스케줄링 => 운영체제가 하는 일
프로세스를 ram에 할당함 => 운영체제가 하는 일
다른 프로세스가 ram 공간에 접근하면 프로그램이 죽음

운영체제는 cpu와 메모리를 프로세스에게 분배한다.
메모리는 그런 일이 동시에 일어남(멀티태스킹) => 동기화가 중요하다.



스레드마다 stack, 프로세스마다 heap과 실행코드 영역을 갖는다.
자기방 = stack, 거실 = heap

### 가상메모리 시스템
ram과 hdd를 하나의 논리적 메모리로 추상화시킨 메모리 관리 방법.
=> 효율때문에

메모리를 운영체제가 관리함(단위 = 페이지)
- 운영체제는 실행중인 모든 프로그램마다 4GB씩 메모리를 사용할 수 있다고 이야기한다.
- 모든 메모리는 '페이지'단위로 관리되며 Paged될 수 있는 '페이징 풀' 영역과 절대로 Paged되면 안되는 '비페이징 풀'영역이 있다.
- 프로세스가 운영체제로부터 메모리를 할당 받는 일은 꽤 시간이 많이 걸리는 일이다.


컴퓨터가 연산을 하려면 주기억장치가 필요하다.
프로그램이 동시에 실행되면 페이지단위로 운영체제가 메모리를 준다.
그러면 주기억장치가 페이지 하나를 잘라서 씀
 Page Out(Swap Out) 실제로 연산을 안하는 프로그램을 ram 밖으로(ex: hdd로) 내보냄
 
 정해진 메모리 공간을 분할해서 공유하는 기법이 가상메모리다.
 그때 관리 단위가 페이지고 주기억장치가 부족하면 하드디스크로 뺀다.
 
 프로그램이 여러개 작동하면 나머지 보조기억장치를 활용함으로써 동시에 작동할 수 있다.
